<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python on Biologically Plausible Programming</title>
    <link>/tags/python/</link>
    <description>Recent content in python on Biologically Plausible Programming</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2020. All rights reserved.</copyright>
    <lastBuildDate>Mon, 22 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>PyTorch Dataset Class: Simply Elegant</title>
      <link>/22/02/2021/pytorch-dataset-class-simply-elegant/</link>
      <pubDate>Mon, 22 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>/22/02/2021/pytorch-dataset-class-simply-elegant/</guid>
      <description>Introduction
Over the past few weeks, I have been experimenting with and learning more about the popular PyTorch (torch) package that like Keras and Tensorflow, provides an easy way to implement deep learning algorithms. In this post, I show why I think torch&amp;rsquo;s Dataset class is an elegant and beginner-friendly way to handle the process of data processing. As I have written previously, it&amp;rsquo;s more important to ensure you have the correct data than actually implementing a target model.</description>
    </item>
    
    <item>
      <title>Open Source Software: The Case for Student Involvement</title>
      <link>/06/10/2020/open-source-student-involvement/</link>
      <pubDate>Tue, 06 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>/06/10/2020/open-source-student-involvement/</guid>
      <description>Introduction
For over two years now, I have devoted most of my time to either building open source software or alerting developers of issues with &amp;ldquo;their&amp;rdquo; software. I use their in quotes because open source software really is community software and most developers have the community&amp;rsquo;s needs first.
During this time, I have grown a lot as a developer and believe that most of this growth has come from my involvement with developer communities be it over at StackOverflow or GitHub.</description>
    </item>
    
    <item>
      <title>Minimizing Loss: Lessons From a Summer of Deep Learning</title>
      <link>/14/09/2020/minimizing-loss-lessons-from-a-summer-of-deep-learning/</link>
      <pubDate>Mon, 14 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>/14/09/2020/minimizing-loss-lessons-from-a-summer-of-deep-learning/</guid>
      <description>Introduction
While there is debate on how much similar deep learning(DL) operations are to the corresponding brain computations, these operations have been applied to several problems often generating excitement and sometimes unwarranted hype. Of all the DL applications, image processing has considerably matured and provided better results compared to traditional processes that relied on simple(r) kernel convolutions.
For the biomedical community, the UNet algorithm proposed by Ronneberger et al.(2015) has successfully been applied to several problems ranging from basic segmentation tasks to more complex tasks like cell tracking and cell cycle progress monitoring.</description>
    </item>
    
    <item>
      <title>R Loops for the Python Programmer</title>
      <link>/21/07/2020/r-loops-for-the-python-programmer/</link>
      <pubDate>Tue, 21 Jul 2020 23:35:25 +0800</pubDate>
      
      <guid>/21/07/2020/r-loops-for-the-python-programmer/</guid>
      <description>TLDR: Whenever possible use vectorised alternatives instead of loops, seq_along and 1:length will be handy when looping through data.
The R vs Python debate is one that has stood the test of time. Thousands of articles and tweets have been made that aim to argue for the use of one language over another. Fortunately for the reader, this post is not aimed at justifying the use of one language.
On the contrary, as someone who is fairly proficient in both languages, I thought it would be nice to write about key differences between loops in R and python.</description>
    </item>
    
    <item>
      <title>Semi Automated Edge Detection with pyautocv</title>
      <link>/27/05/2020/semi-automated-edge-detection-with-pyautocv/</link>
      <pubDate>Wed, 27 May 2020 00:00:00 +0000</pubDate>
      
      <guid>/27/05/2020/semi-automated-edge-detection-with-pyautocv/</guid>
      <description>In this short post, we take a look at how we can use pyautocv for edge detection. At the time of writing, pyautocv was at version 0.2.1 that was unreleased.
For installation details, please see the documentation of the project.
Pre-requisites
 Python &amp;gt;=3.6 pyautocv &amp;gt;=0.2.1 An image directory for which detection is required.  To begin, we import pyautocv&amp;rsquo;s Segmentation class.
from pyautocv.segmentation import *Next, we change directory to the target directory that holds our images.</description>
    </item>
    
  </channel>
</rss>
